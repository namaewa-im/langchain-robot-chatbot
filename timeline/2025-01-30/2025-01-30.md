## ğŸ“… 2025-01-31 - Daily Learning Log

---

### ğŸ“ What I Learned Today

#### References
[Langgraph Glossary](https://langchain-ai.github.io/langgraph/concepts/low_level/?h=reducer#why-use-messages)

#### Reducer

`Annotated`Â ë¡œ reducer functionì„ ì§€ì •í•  ìˆ˜ ìˆë‹¤. bar: list[str] ë¡œ í•˜ë©´ ê¸°ë³¸ì ìœ¼ë¡œ barë¼ëŠ” TypeState ë³€ìˆ˜ê°€ update ë˜ë©´ overwrite ë˜ëŠ”ë° bar: Annotated[list[str], add] ì´ëŸ°ì‹ìœ¼ë¡œ ì‘ì„±í•˜ë©´ `operator.add` ë¡œ ì´ì–´ ë¶™ì—¬ì§„ë‹¤. ì˜ˆë¥¼ ë“¤ì–´ inputìœ¼ë¡œ `{"foo": 1, "bar": ["hi"]}`ë¥¼ ë„£ê³  ë‹¤ìŒ nodeì˜ outputì´ `{"bar": ["bye"]}`Â ì´ë©´ StateëŠ” Â `{"foo": 2, "bar": ["hi", "bye"]}` ê°€ ëœë‹¤. 

**Human-in-the-loop**

ê·¸ë˜í”„ì˜ Stateì•ˆì— Messagesë¥¼ ì¶•ì í•˜ë©´ chat modelì˜ ì´ì ì„ ë” ì¦í­ì‹œí‚¬ ìˆ˜ ìˆë‹¤. ì‚¬ìš©ìê°€ ë©”ì‹œì§€ë¥¼ ì§ì ‘ ì…ë ¥í•˜ì—¬ Stateì•ˆì— messagesë¥¼ ì¶”ê°€í•  ìˆ˜ ìˆë‹¤. (human-in-the-loop)

`Command`Â is an important part of human-in-the-loop workflows.


**Node config**

nodesëŠ” python function(sync or async)ì´ë‹¤. ê·¸ë¦¬ê³  argumentsëŠ” state, config(optionalÂ [configurable parameters](/https://langchain-ai.github.io/langgraph/concepts/low_level/?h=reducer#configuration))ì´ë‹¤. 

```python
def my_node(state: dict, config: RunnableConfig):
    print("In node: ", config["configurable"]["user_id"])
    return {"results": f"Hello, {state['input']}!"}
```

**Conditional Edges**

EdgesëŠ” ë¡œì§ì´ stateë¥¼ routeí•˜ëŠ” ë°©ë²• í˜¹ì€ ê·¸ë˜í”„ì˜ ì¤‘ë‹¨ì„ ê²°ì •í•˜ëŠ” ë°©ë²•ì„ ì •ì˜í•œë‹¤. 

â€¢ Conditional Edges: Call a function to determine which node(s) to go to next.
add_conditional_edges()ëŠ” â€œrouting functionâ€ nodeê°€ í•„ìš”í•˜ë‹¤.
`graph.add_conditional_edges("node_a", routing_function)`
â€œrouting functionâ€ nodeëŠ” í˜„ì¬ stateë¥¼ ì…ë ¥ìœ¼ë¡œ ë°›ì•„ a valueë¥¼ ë°˜í™˜í•œë‹¤. 

How to? 
provide a dictionary that maps theÂ `routing_function`'s output to the name of the next node.
`graph.add_conditional_edges("node_a", routing_function, {True: "node_b", False: "node_c"})`

return valueì™€ nodeë¥¼ dictë¡œ ë¬¶ëŠ”ë‹¤. 

**Command**

CommandëŠ” edgesì™€ nodesë¥¼ single functionìœ¼ë¡œ ë¬¶ì„ ìˆ˜ ìˆëŠ” ë°©ë²•ì´ë‹¤.
UseÂ `Command`Â when you need toÂ **both**Â update the graph stateÂ **and**Â route to a different node.

from above to below

```python
def my_node(state: State) -> Command[Literal["my_other_node"]]:
    return Command(
        # state update
        update={"foo": "bar"},
        # control flow
        goto="my_other_node"
    )
```

```python
def my_node(state: State) -> Command[Literal["my_other_node"]]:
    if state["foo"] == "bar":
        return Command(update={"foo": "baz"}, goto="my_other_node")
```

**When returningÂ `Command`Â in your node functions, you must add return type annotations with the list of node names the node is routing to, e.g.Â `Command[Literal["my_other_node"]]`. This is necessary for the graph rendering and tells LangGraph thatÂ `my_node`Â can navigate toÂ `my_other_node`.

**using command for subgraphs**

If you are usingÂ [subgraphs](https://langchain-ai.github.io/langgraph/concepts/low_level/?h=reducer#subgraphs), you might want to navigate from a node a subgraph to a different subgraph (i.e. a different node in the parent graph). 
To do so, you can specifyÂ `graph=Command.PARENT`Â inÂ `Command`:

```python
def my_node(state: State) -> Command[Literal["my_other_node"]]:
    return Command(
        update={"foo": "bar"},
        goto="other_subgraph",  # where `other_subgraph` is a node in the parent graph
        graph=Command.PARENT
    )
```

**Send**

ì¼ë°˜ì ìœ¼ë¡œ nodeì™€ edgeëŠ” ë™ì¼í•œ stateë¥¼ ê³µìœ í•œë‹¤. í•˜ì§€ë§Œ íŠ¹ì • nodeì—ì„œ ë‹¤ë¥¸ ë²„ì „ì˜ stateë¥¼ ì‚¬ìš©í•˜ê³  ì‹¶ë‹¤ë©´? 

`map-reduce`Â design pattern ì‚¬ìš©í•˜ê¸°. (ë””ìì¸ íŒ¨í„´ì´ë€ ê¸°ì¡´ í™˜ê²½ ë‚´ì—ì„œ ë°˜ë³µì ìœ¼ë¡œ ì¼ì–´ë‚˜ëŠ” ë¬¸ì œë“¤ì„ ì–´ë–»ê²Œ í’€ì–´ë‚˜ê°ˆ ê²ƒì¸ê°€ì— ëŒ€í•œ ì¼ì¢…ì˜ ì†”ë£¨ì…˜ì´ë‹¤.)

`Send`Â ì€ ë‘ê°œì˜ argumentsë¥¼ ê°€ì§„ë‹¤. ì²«ë²ˆì§¸ëŠ” nodeì˜ ì´ë¦„ì´ê³ , ë‘ë²ˆì§¸ëŠ” ê·¸ nodeë¥¼ í†µê³¼í•˜ëŠ” stateì´ë‹¤. 

```python
def continue_to_jokes(state: OverallState):
    return [Send("generate_joke", {"subject": s}) for s in state['subjects']]

graph.add_conditional_edges("node_a", continue_to_jokes)
```

**CheckPointers**

Checkpointers save snapshots of the graph state at every superstep.

**Subgraphs**

ì„œë¸Œê·¸ë˜í”„ë¥¼ ì‚¬ìš©í•˜ëŠ” ì´ìœ 

1. ë©€í‹° ì—ì´ì „íŠ¸ ì‹œìŠ¤í…œ
2. ë…¸ë“œ ì§‘í•©ì˜ ì¬ì‚¬ìš©
3. ì„œë¡œ ë‹¤ë¥¸ íŒ€ì´ ê·¸ë˜í”„ì˜ ê° ë¶€ë¶„ì„ ë…ë¦½ì ìœ¼ë¡œ êµ¬ì¶•í•˜ëŠ” ê²½ìš°

ë¶€ëª¨ ê·¸ë˜í”„ì— ì„œë¸Œ ê·¸ë˜í”„ë¥¼ í†µí•©í•˜ëŠ” ë°©ë²•

1. ê°™ì€ stateë¥¼ ê³µìœ í•  ë•Œ - ì»´íŒŒì¼ëœ í˜•íƒœë¡œ ë¶™ì„

`builder.add_node("subgraph", subgraph_builder.compile())`

1. ë‹¤ë¥¸ stateë¥¼ ì‚¬ìš©í•  ë•Œ - ë¶€ëª¨ ê·¸ë˜í”„ì™€ ì„œë¸Œ ê·¸ë˜í”„ëŠ” ë‘˜ì´ ì •ë³´ë¥¼ ê³µìœ í•  ìˆ˜ ìˆë„ë¡ state ìŠ¤í‚¤ë§ˆê°€ ìµœì†Œí•œ í•˜ë‚˜ì˜ keyëŠ” ê³µìœ í•˜ê³  ìˆì–´ì•¼í•œë‹¤. ì¶”ê°€ì ì¸ ì •ë³´ë¥¼ ë„˜ê²¨ë„ ì„œë¸Œê·¸ë˜í”„ê°€ ì‚¬ìš©í•  ìˆ˜ ì—†ëŠ” í‚¤ëŠ” ìë™ìœ¼ë¡œ ë¬´ì‹œëœë‹¤.

```python
subgraph = subgraph_builder.compile()

def call_subgraph(state: State):
    return subgraph.invoke({"subgraph_key": state["parent_key"]})

builder.add_node("subgraph", call_subgraph)
```

As a compiled graph - ê³µìœ í•˜ê³  ìˆëŠ” í‚¤ê°€ ìˆì„ë•Œ

As a function - ê³µìœ í•˜ëŠ” í‚¤ê°€ ì•„ì˜ˆ ì—†ì„ ë•Œ ì‚¬ìš©í•œë‹¤.
ì§ì ‘ ì„œë¸Œê·¸ë˜í”„ë¥¼ í˜¸ì¶œí•˜ëŠ” í•¨ìˆ˜(node function) ë¥¼ ì‘ì„±í•˜ì—¬ ë°ì´í„°ë¥¼ ë³€í™˜í•´ì„œ ë„˜ê¸°ê³ , ê²°ê³¼ë¥¼ ë‹¤ì‹œ ë³€í™˜í•´ì„œ ë¶€ëª¨ ìƒíƒœë¡œ ë°˜í™˜í•œë‹¤.